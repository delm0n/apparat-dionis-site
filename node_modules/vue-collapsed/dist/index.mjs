import { defineComponent as S, toRef as y, computed as c, ref as h, shallowRef as z, onMounted as A, watch as C, openBlock as B, createBlock as F, resolveDynamicComponent as M, normalizeStyle as R, withCtx as q, renderSlot as N, normalizeProps as P, guardReactiveProps as D } from "vue";
const _ = "--vc-auto-duration", T = `height var(${_}) cubic-bezier(0.33, 1, 0.68, 1)`, v = { padding: 0 }, j = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", border: "0" };
function b(t) {
  return { height: `${(t == null ? void 0 : t.scrollHeight) ?? 0}px` };
}
function $(t) {
  if (!t)
    return {};
  const { transition: n } = getComputedStyle(t);
  return n === "all 0s ease 0s" ? { transition: T } : { transition: n };
}
function H(t) {
  if (!t)
    return !0;
  const { transition: n } = getComputedStyle(t);
  return window.matchMedia("(prefers-reduced-motion: reduce)").matches || n.includes("none") || n.includes("height 0s");
}
S({ inheritAttrs: !0 });
const G = S({ __name: "Collapse", props: { when: { type: Boolean }, baseHeight: { default: 0 }, as: { default: "div" } }, emits: ["collapse", "expand", "collapsed", "expanded"], setup(t, { emit: n }) {
  const p = t, u = y(p, "when"), o = y(p, "baseHeight"), d = c(() => ({ overflow: "hidden", height: `${o.value}px` })), g = c(() => ({ ...v, ...o.value === 0 ? { display: "none" } : d.value })), l = h(null), i = h(u.value ? "expanded" : "collapsed"), e = z({}), f = h(300), m = c(() => ({ [_]: `${f.value}ms` }));
  function x() {
    e.value = v, i.value = "expanded", n("expanded");
  }
  function w() {
    e.value = g.value, i.value = "collapsed", n("collapsed");
  }
  function k(a) {
    var s, r;
    a.target === l.value && a.propertyName === "height" && (u.value ? ((s = l.value) == null ? void 0 : s.scrollHeight) === parseFloat(a.target.style.height) && x() : ((r = l.value) == null ? void 0 : r.style.height) === `${o.value}px` && w());
  }
  return A(() => {
    if (!l.value)
      return;
    u.value || o.value !== 0 || (e.value = j);
    const a = function(s = 0) {
      if (s === 0)
        return 0;
      const r = s / 36;
      return Math.round(10 * (4 + 15 * r ** 0.25 + r / 5));
    }(l.value.scrollHeight - o.value);
    f.value = a <= 0 ? 300 : a, e.value = u.value ? v : g.value;
  }), C(u, (a) => {
    if (a) {
      if (H(l.value))
        return x();
      i.value = "expanding", n("expand"), e.value = { ...v, ...d.value, ...m.value, willChange: "height" }, requestAnimationFrame(() => {
        e.value = { ...e.value, ...b(l.value), ...$(l.value) };
      });
    } else {
      if (H(l.value))
        return w();
      i.value = "collapsing", n("collapse"), e.value = { ...e.value, ...m.value, ...b(l.value), willChange: "height" }, requestAnimationFrame(() => {
        e.value = { ...e.value, ...d.value, ...$(l.value) };
      });
    }
  }), C(o, (a) => {
    u.value || (e.value = { ...e.value, ...a === 0 ? { display: "none" } : { transition: "none", height: `${a}px` } });
  }), (a, s) => (B(), F(M(p.as), { ref_key: "collapseRef", ref: l, style: R(e.value), onTransitionend: k, "data-collapse": i.value }, { default: q(() => [N(a.$slots, "default", P(D({ state: i.value })))]), _: 3 }, 40, ["style", "data-collapse"]));
} });
export {
  G as Collapse
};
