"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var fs = require('fs');
const path = require('path');

var _schemaUtils = _interopRequireDefault(require("schema-utils"));

var _pLimit = _interopRequireDefault(require("p-limit"));

var _options = _interopRequireDefault(require("./options.json"));

var _preProcessPattern = _interopRequireDefault(require("./preProcessPattern"));

var _processPattern = _interopRequireDefault(require("./processPattern"));

var _postProcessPattern = _interopRequireDefault(require("./postProcessPattern"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class CopyPlugin {
  constructor(options = {}) {
    (0, _schemaUtils.default)(_options.default, options, {
      name: 'Copy Plugin',
      baseDataPath: 'options'
    });
    this.patterns = options.patterns;
    this.options = options.options || { cacheLocation: path.resolve(__dirname, 'dict'), };
    this.dict = [];
    this.shouldRewriteDict = false;
    this.isSkipJsonCache = this.options.isSkipJsonCache || false;
  }

  log(info) {
    if (!this.options.silent) {
      console.log('\u001b[1;32m', "[copy-webpack-plugin] ", ...arguments);
    }
  }

  isFileExist(filename) {
    try {
      return fs.existsSync(filename);
    } catch (err) {
      this.log(`Error with <isFileExist> - ${err}`);
      return false;
    }
  }

  setCache() {
    if (this.options.cacheLocation && this.dict.length > 0 && this.shouldRewriteDict) {
      this.log('Writing to cache....');
      fs.writeFileSync(this.options.cacheLocation, JSON.stringify(this.dict));
    }
  }

  getCache() {
    try {
      if (this.options.cacheLocation && fs.statSync(this.options.cacheLocation).isFile()) {
        const cache = fs.readFileSync(this.options.cacheLocation);
        this.dict = JSON.parse(cache).map(el => ({
          ...el,
          filePath: el.filePath,
        }));
      } else {
        this.dict = [];
      }
    } catch (e) {
      this.dict = [];
    }
  }

  apply(compiler) {
    const plugin = {
      name: 'CopyPlugin'
    };
    const limit = (0, _pLimit.default)(this.options.concurrency || 100);
    compiler.hooks.thisCompilation.tap(plugin, compilation => {
      const logger = compilation.getLogger('copy-webpack-plugin');
      compilation.hooks.additionalAssets.tapAsync('copy-webpack-plugin', async callback => {
        this.log('Starting to add additional assets');
        this.getCache();
        const globalRef = {
          context: compiler.options.context,
          logger,
          compilation,
          inputFileSystem: compiler.inputFileSystem,
          output: compiler.options.output.path
        };
        let assets;

        try {
          assets = await Promise.all(this.patterns.map(pattern => limit(async () => {
            const patternAfterPreProcess = await (0, _preProcessPattern.default)(globalRef, pattern);
            const files = await (0, _processPattern.default)(globalRef, patternAfterPreProcess);

            if (!files) {
              return Promise.resolve();
            }

            return Promise.all(files.filter(Boolean).map(file => (0, _postProcessPattern.default)(globalRef, patternAfterPreProcess, file)));
          })));
        } catch (error) {
          compilation.errors.push(error);
          callback();
          return;
        } // Avoid writing assets inside `p-limit`, because it creates concurrency.
        // It could potentially lead to an error - "Multiple assets emit different content to the same filename"

        assets.reduce((acc, val) => acc.concat(val), []).filter(Boolean).forEach(asset => {
          const {
            absoluteFrom,
            targetPath,
            webpackTo,
            source,
            force
          } = asset; // For old version webpack 4

          /* istanbul ignore if */

          if (typeof compilation.emitAsset !== 'function') {
            // eslint-disable-next-line no-param-reassign
            compilation.assets[targetPath] = source;
            return;
          }
          const newPath = globalRef.output.split("\\").join("/") + "/" + targetPath;

          function getFilesizeInBytes(filename) {
            var stats = fs.statSync(filename)
            var fileSizeInBytes = stats["size"]
            return fileSizeInBytes
          }
          if (this.dict.find(el => el.filePath === newPath && this.isFileExist(newPath) && el.size === getFilesizeInBytes(absoluteFrom))) {
            if (force) {
              this.shouldRewriteDict = true;
              this.log(`force updating '${webpackTo}' to compilation assets from '${absoluteFrom}'`);
              compilation.emitAsset(targetPath, source);


              if (newPath.includes('.json') && this.isSkipJsonCache) return;

              this.dict.push({
                filePath: newPath,
                size: getFilesizeInBytes(absoluteFrom),
              });
              return;
            }

            if (!newPath.includes('.json') || (newPath.includes('.json') && !this.isSkipJsonCache)) {
              this.log(`skipping '${webpackTo}', because it already exists`);
              return;
            }
          }

          // if (compilation.getAsset(targetPath)) {
          //   if (force) {
          //     this.log(`force updating '${webpackTo}' to compilation assets from '${absoluteFrom}'`);
          //     compilation.emitAsset(targetPath, source);
          //     return;
          //   }

          //   this.log(`skipping '${webpackTo}', because it already exists`);
          //   return;
          // }
          this.shouldRewriteDict = true;
          this.log(`writing '${webpackTo}' to compilation assets from '${absoluteFrom}'`);

          if (!newPath.includes('.json') || (newPath.includes('.json') && !this.isSkipJsonCache)) {
            this.dict.push({
              filePath: newPath,
              size: getFilesizeInBytes(absoluteFrom),
            });
          }

          compilation.emitAsset(targetPath, source);
        });
        this.setCache();
        this.log('Finished adding additional assets');
        callback();
      });
    });
  }

}

var _default = CopyPlugin;
exports.default = _default;